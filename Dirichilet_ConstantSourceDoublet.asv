% This function provides the lift and pressure distribution characteristics
% for a 2-D airfoil in an inviscid, incompressible, irrotational flow

%{INPUTS}%
% Bp = (X,Y) Cartesion boundary points of body panels
% alphaD = angle of attack in degrees
% U = free-stream velocity magnitude

%{OUTPUTS}%
% result.mu = vector containin the doublet strength of each panel
% result.Cp = pressure coefficient at the control point of each panel
% result.cl = lift coefficient based on circulation and Kelvin's theorem of lift
% result.X_Cp = control point x-coordinates for pressure coefficient plotting

function result = Dirichilet_ConstantSourceDoublet(Bp, alphaD, U)
% Pre-Process input variables
Bp = flipud(Bp); % Force Clockwise Paneling
alphaR = (pi/180)*alphaD; % Convert angle of attack to radians

% Establish iteration variables
NN = length(Bp(:,1)); % Number of boundary points ------ % M1
numPan = NN - 1; % Number of body panels ---- % M
num_d = NN; % Number of doublets including wake (should be same as number of boundary points for 2-D implementation)  --- %N

% Establish Panel Geometry -- methods based on Program No. 9 from Low Speed Aerodynamics (Katz & Plotkin, 2011)
dxy = diff(Bp); % Panel x lengths (column 1) and y lengths (column 2)
th = atan2(dxy(:,2), dxy(:,1)); % Panel angle with respect to positive x-axis


% Prescribe Source Strengths
sigma = U*(cos(alphaR).*sin(th) - sin(alphaR).*cos(th)); % Setting source strength equal to free stream velocity normal component at each panel

% Define vector of control points
co = 0.5*(Bp(1:numPan,:)+Bp(2:numPan+1,:)); % numPan X 2 vector of control point coordinates
cx = co(:,1); cz = co(:,2); % x and z coordinates of control points

% Extract panel boundary point vectors for use in coordinate frame rotation
Bp1 = Bp(1:numPan, :); Bp1_x = Bp1(:,1); Bp1_z = Bp1(:,2); % First boundary point vector, and corresponding x and z points
Bp2 = Bp(2:numPan+1, :); Bp2_x = Bp2(:,1); Bp2_z = Bp2(:,2); % First boundary point vector, and corresponding x and z points

A = zeros(NN+1, NN+1); % Initialize influence matrix
Lp = zeros(numPan,1); % Initialize vector of panel lengths


% Transform collocation points to local panel coordinates
 Xg = cx - Bp1_x.';
 Zg = cz - Bp1_z.';
 
 X2g = Bp2_x - Bp1_x;
 Z2g = Bp2_z - Bp1_z;
 
 cos_th = cos(th);
 sin_th = sin(th);
 
 % Perform coordinate rotation
 Xp = Xg .* repmat(cos_th.', numPan,1) + Zg .*repmat(sin_th.', numPan,1);
 Zp = -Xg .*repmat(sin_th.', numPan,1) + Zg .* repmat(cos_th.', numPan,1);
 
 X2p_vec = X2g .* cos_th + Z2g .* sin_th; % numPan Ã— 1
 
 % expand explicitly across rows
 X2p = ones(numPan,1) * X2p_vec.';
 
 % Compute panel lengths
 Lp = X2p_vec(:);
 
 % Distances between boundary points and collocation points (each column is jth panel, each row
 % is ith collocation point)
 r1 = sqrt(Xp.^2 + Zp.^2);
 r2 = sqrt((Xp - X2p).^2 + Zp.^2);
 
 % Angles between boundary points and collocation points (each column is jth panel, each row
 % is ith collocation point)
 thp = atan2(Zp, Xp);
 thp2 = atan2(Zp, Xp - X2p);
 
 % Compute Doublet Potential Influence Coefficient Matrix
 A = -(1/(2*pi))*(thp2 - thp);
 
 % Self influence correction
 A(1:numPan+1:end) = 0.5;
 
 
 % Compute source potential influence coefficient matrix
 SourceInfluence = (1/(2*pi))*( ...
 Xp .* log(r1) ...
 - (Xp - X2p) .* log(r2) ...
 + Zp .* (thp2 - thp) ...
 );
 
 % Self source correction
 diag_idx = 1:numPan+1:numPan^2;
 SourceInfluence(diag_idx) = (1/pi)*(Xp(diag_idx).*log(r1(diag_idx)));
 
 % Multiply by sigma and sum across panels
 RHS = SourceInfluence * sigma;

 % Compute distance between wake panel collocation points and body panel
 % collocation points
 xw = cx - Bp2(numPan,1);
 zw = cz - Bp2(numPan,2);
 
 % Angle between wake panel collocation point and body collocation points
 thw = -atan(zw./xw);
 
 % Assemble full matrix
 A_full = zeros(numPan+1, numPan+1);
 
 A_full(1:numPan,1:numPan) = A; % Doublet body panel influence coefficients
 A_full(1:numPan,num_d) = -(1/(2*pi))*thw; % Wake panel influence coefficients
 A_full(1:numPan,num_d+1) = RHS; % Source influence (strength x influence coefficient)
 
 % Apply Kutta Condition to trailing edge
 A_full(numPan+1,:) = 0;
 A_full(numPan+1,1) = -1;
 A_full(numPan+1,numPan) = 1;
 A_full(numPan+1,numPan+1) = -1;


% Solve matrix equations for doublet strengths

 b = A_full(:, num_d+1); % Isolate source RHS terms
 A = A_full(:, 1:num_d); % Create matrix of only doublet coefficients (including wake)

 mu = A\b; % Solve for source strengths

 %% ===== Compute Surface Velocity and Aerodynamics Loads =====

 % Initialize variables
 phi = cx*cos(alphaR) + cz*sin(alphaR) + mu(1:numPan); % Compute panel potentials
 Cp = zeros(numPan-1, 1); % Initialize Pressure Coefficient Matrix
 X_Cp = zeros(numPan-1, 1); % Corresponding Cp x-coordinate
 Vt = zeros(numPan-1, 1); % Initialize panel surface velocity vector

 % Compute surface velocity using forward difference method
 dS = (Lp(2:numPan) + Lp(1:numPan-1))/2; % Surface increment
 dphi = phi(1:numPan-1) - phi(2:numPan); % O
 Vt = dphi ./ dS;

 Cp = 1 - (Vt./U).^2;

 X_Cp = Bp2(1:numPan-1,1);


 gamma = -sum(Vt(:).*Lp(1:numPan-1, :));
 cl = 2*gamma; % lift coefficient



% Export Results
result.mu = mu; % Export doublet strength vector
result.Cp = Cp; % Export Pressure Coefficient
result.cl = cl; % Export Lift Coefficient
result.X_Cp = X_Cp; % Export X coordinates of pressure coefficient evaluation points 


end

%% Non Vectorized Algorithm
% Compute potential influence coefficients (algorithm based on Program No. 9 of Low Speed Aerodynamics (Katz & Plotkin, 2011)
% for i = 1:numPan
%     temp = 0;
%     for j = 1:numPan
%         % Transform collocation point to panel-local coords
%         Xg  = co(i,1) - Bp1(j,1);
%         Zg  = co(i,2) - Bp1(j,2);
%         X2g = Bp2(j,1) - Bp1(j,1);
%         Z2g = Bp2(j,2) - Bp1(j,2);
% 
%         Xp  = Xg*cos(th(j)) + Zg*sin(th(j));
%         Zp  = -Xg*sin(th(j)) + Zg*cos(th(j));
%         X2p = X2g*cos(th(j)) + Z2g*sin(th(j));
% 
%         if i == 1
%             Lp(j) = X2p; % Store panel lengths
%         end
% 
%         r1 = sqrt(Xp^2 + Zp^2); % Distance between first boundary point of jth panel and ith panel collocation point
%         r2 = sqrt((Xp-X2p)^2 + Zp^2); % Distance between second boundary point of jth panel and ith panel collocation point
% 
%         thp = atan2(Zp, Xp); % Angle between first boundary point of jth panel and ith panel collocation point
%         thp2 = atan2(Zp, (Xp - X2p)); % Angle between second boundary point of jth panel and ith panel collocation point
% 
%         % Compute Doublet Potential Influence Coefficients
% 
%         if i == j
%             A(i,j) = 0.5; % Doublet self influence of ith panel
%         else
%             A(i,j) = -(1/(2*pi))*(thp2-thp); % Influence of jth doublet on ith panel
%         end
% 
%         % source influence stored in temp
%         if i == j
%             temp = temp + (1/pi)*(Xp*log(r1))*sigma(j); % Source self influence of ith panel
%         else
%             temp = temp + (1/(2*pi))*((Xp*log(r1)) - ((Xp-X2p)*log(r2)) + (Zp*(thp2 - thp)))*sigma(j); % Influence of jth source on ith panel
%         end
%     end
% 
%     %Compute Wake infuence on ith panel
% 
%     xw = co(i,1) - Bp2(numPan,1);
%     zw = co(i,2) - Bp2(numPan, 2);
% 
%     thw = -atan(zw/xw);
% 
%     A(i, num_d) = -(1/(2*pi))*thw; 
%     A(i, num_d+1) = temp;
% end


% % Add an Explicit Kutta Condition
% A(numPan+1, :) = 0;
% A(numPan+1, 1) = -1;
% A(numPan+1, numPan) = 1;
% A(numPan+1, num_d) = -1;


% % Solve System of equations
% b = A(:, num_d+1); % Isolate source RHS terms
% A = A(:, 1:num_d); % Create matrix of only doublet coefficients (including wake)

% mu = A\b; % Solve for source strengths
% 
% % Compute Surface Velocity and Aerodynamics Loads
% phi = cx*cos(alphaR) + cz*sin(alphaR) + mu(1:numPan);
% Cp = zeros(numPan-1, 1); % Initialize Pressure Coefficient Matrix
% X_Cp = zeros(numPan-1, 1); % Corresponding Cp x-coordinate
% Vt = zeros(numPan-1, 1);
% 
% for i = 1:numPan-1
% dS = (Lp(i+1) + Lp(i))/2;
% dphi = (phi(i)-phi(i+1));
% Vt(i) = dphi/dS; % Compute tangential velocity
% Cp(i) = 1-(Vt(i)/U)^2;
% X_Cp(i) = Bp2(i,1);
% end
% 


% gamma = -sum(Vt(:).*Lp(1:numPan-1, :));
% cl = 2*gamma; % lift coefficient
%%
